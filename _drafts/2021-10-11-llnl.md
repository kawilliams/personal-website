---
layout: post
title:  "Call Trees in Jupyter Notebooks [LLNL]"
date:   2021-10-11
categories: data-vis
image: images/plushies.jpg
relative_url: "../../../../"
permalink: /abstractions/
---


<img src='{{ "images/atria.jpg" | relative_url }}' width="508px"/> 

**I built an [interactive call tree visualization](https://hatchet.readthedocs.io/en/latest/user_guide.html#visualizing-the-data) to supplement the Hatchet library.**

**Description**: 
High-performance computer scientists instrument their code at specific areas with [Caliper](https://github.com/LLNL/Caliper) to gather performance data as their code runs, so that they can retroactively look at where slowdowns occurred. Then they open a Jupyter notebook and use the Python-based library called [Hatchet](https://github.com/hatchet/hatchet) to index the dataframes of their performance data and graph data. The users also want to see a representation of the calling context tree of the program (shown here on the left), which is an output that shows how functions called other functions and how long each function took to execute. To supplement the current terminal-like tree visualization in Hatchet from the previous slide, I built an interactive tree that gives users a way to explore the call tree and extract subtrees within the Jupyter notebook cells.

<img src='{{ "images/vis-terminal.jpg" | relative_url }}' width="200px"/> 

<img src='{{ "images/jupyter-tree-overview.jpg" | relative_url }}' width="995px"/> 
### Repositories

A. Bigelow, K. Williams, and K. E. Isaacs.
[Guidelines For Pursuing and Revealing Data Abstractions](/people/kawilliams/papers/bigelow_20200preprint_dataabstractions.pdf). Submitted to IEEE VIS 2020. 
